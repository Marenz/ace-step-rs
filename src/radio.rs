//! Radio station: whole-song generation with a request queue.
//!
//! Generates complete songs one at a time, always keeping one song buffered
//! ahead of playback. Users submit [`SongRequest`]s (structured or free-text)
//! which are queued and consumed in order. When the queue is empty the station
//! asks the LLM translator to invent something that fits the recent vibe.
//!
//! Duration is auto-sized from lyrics (100–600 s range) unless overridden.

use std::collections::VecDeque;

use crate::pipeline::{AceStepPipeline, GeneratedAudio, GenerationParams, format_metas};

/// A request for a single song.
#[derive(Debug, Clone)]
pub struct SongRequest {
    /// Style / genre description (the model's caption input).
    pub caption: String,
    /// Lyrics text (newline-separated lines).
    pub lyrics: String,
    /// BPM, or `None` for model default.
    pub bpm: Option<u32>,
    /// Key/scale, e.g. "A minor", or `None`.
    pub key_scale: Option<String>,
    /// Time signature, e.g. "4/4". Defaults to "4/4".
    pub time_signature: String,
    /// Language code (e.g. "en", "zh").
    pub language: String,
    /// Desired duration in seconds (100–600). `None` = auto-size from lyrics.
    pub duration_s: Option<f64>,
    /// Random seed. `None` = random.
    pub seed: Option<u64>,
    /// Shift parameter for turbo schedule (1, 2, or 3). Default: 3.
    pub shift: f64,
    /// Whether this was generated by the LLM (not user-submitted).
    pub auto_generated: bool,
}

impl Default for SongRequest {
    fn default() -> Self {
        Self {
            caption: String::new(),
            lyrics: String::new(),
            bpm: None,
            key_scale: None,
            time_signature: "4/4".to_string(),
            language: "en".to_string(),
            duration_s: None,
            seed: None,
            shift: 3.0,
            auto_generated: false,
        }
    }
}

/// Minimum song duration in seconds.
pub const MIN_DURATION_S: f64 = 100.0;
/// Maximum song duration in seconds.
pub const MAX_DURATION_S: f64 = 600.0;
/// Default duration when no lyrics and no explicit duration are given.
pub const DEFAULT_DURATION_S: f64 = 180.0;
/// Estimated seconds of audio per line of lyrics.
const SECONDS_PER_LINE: f64 = 8.0;

/// Estimate song duration from lyrics line count, clamped to [MIN, MAX].
/// Returns `DEFAULT_DURATION_S` if lyrics are empty.
pub fn estimate_duration_from_lyrics(lyrics: &str) -> f64 {
    let lines = lyrics.lines().filter(|l| !l.trim().is_empty()).count();
    if lines == 0 {
        return DEFAULT_DURATION_S;
    }
    let estimate = lines as f64 * SECONDS_PER_LINE;
    estimate.clamp(MIN_DURATION_S, MAX_DURATION_S)
}

/// A completed song: the request that produced it + its audio.
#[derive(Clone)]
pub struct CompletedSong {
    /// The request that generated this song.
    pub request: SongRequest,
    /// Generated audio (48 kHz stereo interleaved f32).
    pub audio: GeneratedAudio,
    /// Index in the station's history (monotonically increasing).
    pub song_index: usize,
}

/// The radio station state machine.
///
/// Owns the request queue, history ring, and generation logic.
/// Does *not* own playback — that lives in the daemon.
pub struct RadioStation {
    /// Pending song requests, consumed FIFO.
    queue: VecDeque<SongRequest>,
    /// Recently completed songs (for vibe continuity context).
    history: VecDeque<SongRequest>,
    /// Maximum number of songs to keep in history.
    history_limit: usize,
    /// Monotonically increasing song counter.
    song_counter: usize,
}

impl RadioStation {
    pub fn new(history_limit: usize) -> Self {
        Self {
            queue: VecDeque::new(),
            history: VecDeque::new(),
            history_limit,
            song_counter: 0,
        }
    }

    /// Push a request to the back of the queue.
    pub fn enqueue(&mut self, request: SongRequest) {
        self.queue.push_back(request);
    }

    /// Number of queued requests.
    pub fn queue_len(&self) -> usize {
        self.queue.len()
    }

    /// View the queued requests (read-only).
    pub fn queue(&self) -> &VecDeque<SongRequest> {
        &self.queue
    }

    /// Clear all queued requests.
    pub fn clear_queue(&mut self) {
        self.queue.clear();
    }

    /// View recent history (read-only).
    pub fn history(&self) -> &VecDeque<SongRequest> {
        &self.history
    }

    /// Total songs generated so far.
    pub fn song_counter(&self) -> usize {
        self.song_counter
    }

    /// Pop the next request from the queue.
    /// Returns `None` if the queue is empty (caller should ask the LLM).
    pub fn pop_request(&mut self) -> Option<SongRequest> {
        self.queue.pop_front()
    }

    /// Record a completed song in history.
    pub fn record_completed(&mut self, request: SongRequest) {
        self.song_counter += 1;
        self.history.push_back(request);
        while self.history.len() > self.history_limit {
            self.history.pop_front();
        }
    }

    /// Build a history summary string for LLM context.
    /// Lists the last N songs' captions and params so the LLM can
    /// maintain vibe continuity.
    pub fn history_summary(&self) -> String {
        if self.history.is_empty() {
            return "No songs played yet.".to_string();
        }
        let mut s = String::new();
        for (i, req) in self.history.iter().enumerate() {
            let bpm = req
                .bpm
                .map(|b| b.to_string())
                .unwrap_or_else(|| "N/A".to_string());
            let key = req.key_scale.as_deref().unwrap_or("N/A");
            let dur = req
                .duration_s
                .map(|d| format!("{:.0}s", d))
                .unwrap_or_else(|| "auto".to_string());
            s.push_str(&format!(
                "  {}. [{}] caption={:?} bpm={} key={} dur={}\n",
                i + 1,
                req.language,
                &req.caption[..req.caption.len().min(80)],
                bpm,
                key,
                dur,
            ));
        }
        s
    }

    /// Resolve the duration for a request: use explicit value, or estimate
    /// from lyrics, clamped to [100, 600].
    pub fn resolve_duration(request: &SongRequest) -> f64 {
        match request.duration_s {
            Some(d) => d.clamp(MIN_DURATION_S, MAX_DURATION_S),
            None => estimate_duration_from_lyrics(&request.lyrics),
        }
    }

    /// Convert a [`SongRequest`] into pipeline [`GenerationParams`].
    pub fn to_generation_params(request: &SongRequest) -> GenerationParams {
        let duration_s = Self::resolve_duration(request);
        let metas = format_metas(
            request.bpm,
            Some(request.time_signature.as_str()),
            request.key_scale.as_deref(),
            Some(duration_s),
        );
        let seed = request.seed.or_else(|| {
            Some(
                std::time::SystemTime::now()
                    .duration_since(std::time::UNIX_EPOCH)
                    .unwrap()
                    .as_nanos() as u64,
            )
        });

        GenerationParams {
            caption: request.caption.clone(),
            metas,
            lyrics: request.lyrics.clone(),
            language: request.language.clone(),
            duration_s,
            shift: request.shift,
            seed,
            src_latents: None,
            chunk_masks: None,
            refer_audio: None,
            refer_order: None,
        }
    }

    /// Generate a song from a request using the given pipeline.
    /// Records it in history and returns the completed song.
    pub fn generate(
        &mut self,
        pipeline: &mut AceStepPipeline,
        request: SongRequest,
    ) -> crate::Result<CompletedSong> {
        let params = Self::to_generation_params(&request);
        let duration_s = params.duration_s;
        tracing::info!(
            "Generating song #{}: caption={:?} duration={:.0}s bpm={:?} key={:?}",
            self.song_counter,
            &request.caption[..request.caption.len().min(60)],
            duration_s,
            request.bpm,
            request.key_scale,
        );

        let audio = pipeline.generate(&params)?;
        let song_index = self.song_counter;
        self.record_completed(request.clone());

        Ok(CompletedSong {
            request,
            audio,
            song_index,
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_estimate_duration_empty_lyrics() {
        assert_eq!(estimate_duration_from_lyrics(""), DEFAULT_DURATION_S);
    }

    #[test]
    fn test_estimate_duration_short_lyrics() {
        // 5 lines × 8s = 40s → clamped to MIN_DURATION_S (100)
        let lyrics = "line one\nline two\nline three\nline four\nline five";
        assert_eq!(estimate_duration_from_lyrics(lyrics), MIN_DURATION_S);
    }

    #[test]
    fn test_estimate_duration_medium_lyrics() {
        // 20 lines × 8s = 160s → within range
        let lyrics = (0..20)
            .map(|i| format!("line {i}"))
            .collect::<Vec<_>>()
            .join("\n");
        let d = estimate_duration_from_lyrics(&lyrics);
        assert!((d - 160.0).abs() < 0.01);
    }

    #[test]
    fn test_estimate_duration_long_lyrics() {
        // 100 lines × 8s = 800s → clamped to MAX_DURATION_S (600)
        let lyrics = (0..100)
            .map(|i| format!("line {i}"))
            .collect::<Vec<_>>()
            .join("\n");
        assert_eq!(estimate_duration_from_lyrics(&lyrics), MAX_DURATION_S);
    }

    #[test]
    fn test_estimate_duration_blank_lines_ignored() {
        let lyrics = "line one\n\n\nline two\n  \nline three";
        // 3 non-blank lines × 8s = 24s → clamped to 100
        assert_eq!(estimate_duration_from_lyrics(lyrics), MIN_DURATION_S);
    }

    #[test]
    fn test_resolve_duration_explicit() {
        let req = SongRequest {
            duration_s: Some(300.0),
            ..Default::default()
        };
        assert_eq!(RadioStation::resolve_duration(&req), 300.0);
    }

    #[test]
    fn test_resolve_duration_explicit_clamped() {
        let req = SongRequest {
            duration_s: Some(9999.0),
            ..Default::default()
        };
        assert_eq!(RadioStation::resolve_duration(&req), MAX_DURATION_S);
    }

    #[test]
    fn test_resolve_duration_auto() {
        let lyrics = (0..25)
            .map(|i| format!("verse {i}"))
            .collect::<Vec<_>>()
            .join("\n");
        let req = SongRequest {
            lyrics,
            ..Default::default()
        };
        // 25 lines × 8s = 200s
        assert_eq!(RadioStation::resolve_duration(&req), 200.0);
    }

    #[test]
    fn test_queue_and_pop() {
        let mut station = RadioStation::new(5);
        assert_eq!(station.queue_len(), 0);
        assert!(station.pop_request().is_none());

        station.enqueue(SongRequest {
            caption: "jazz".into(),
            ..Default::default()
        });
        station.enqueue(SongRequest {
            caption: "rock".into(),
            ..Default::default()
        });
        assert_eq!(station.queue_len(), 2);

        let first = station.pop_request().unwrap();
        assert_eq!(first.caption, "jazz");
        let second = station.pop_request().unwrap();
        assert_eq!(second.caption, "rock");
        assert!(station.pop_request().is_none());
    }

    #[test]
    fn test_history_limit() {
        let mut station = RadioStation::new(3);
        for i in 0..5 {
            station.record_completed(SongRequest {
                caption: format!("song {i}"),
                ..Default::default()
            });
        }
        assert_eq!(station.history().len(), 3);
        assert_eq!(station.history()[0].caption, "song 2");
        assert_eq!(station.history()[2].caption, "song 4");
        assert_eq!(station.song_counter(), 5);
    }

    #[test]
    fn test_clear_queue() {
        let mut station = RadioStation::new(5);
        station.enqueue(SongRequest::default());
        station.enqueue(SongRequest::default());
        station.clear_queue();
        assert_eq!(station.queue_len(), 0);
    }

    #[test]
    fn test_to_generation_params() {
        let req = SongRequest {
            caption: "ambient drone".into(),
            lyrics: (0..20)
                .map(|i| format!("line {i}"))
                .collect::<Vec<_>>()
                .join("\n"),
            bpm: Some(90),
            key_scale: Some("D minor".into()),
            time_signature: "3/4".into(),
            language: "en".into(),
            duration_s: None, // auto
            seed: Some(42),
            shift: 3.0,
            auto_generated: false,
        };
        let params = RadioStation::to_generation_params(&req);
        assert_eq!(params.caption, "ambient drone");
        assert_eq!(params.duration_s, 160.0); // 20 lines × 8s
        assert!(params.metas.contains("90"));
        assert!(params.metas.contains("D minor"));
        assert!(params.metas.contains("3/4"));
        assert_eq!(params.seed, Some(42));
    }

    #[test]
    fn test_history_summary_empty() {
        let station = RadioStation::new(5);
        assert_eq!(station.history_summary(), "No songs played yet.");
    }

    #[test]
    fn test_history_summary_with_songs() {
        let mut station = RadioStation::new(5);
        station.record_completed(SongRequest {
            caption: "smooth jazz".into(),
            bpm: Some(100),
            key_scale: Some("Bb major".into()),
            duration_s: Some(180.0),
            ..Default::default()
        });
        let summary = station.history_summary();
        assert!(summary.contains("smooth jazz"));
        assert!(summary.contains("100"));
        assert!(summary.contains("Bb major"));
    }
}
